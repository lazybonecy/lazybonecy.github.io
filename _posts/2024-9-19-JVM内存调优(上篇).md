---
layout: post
title: JVM内存调优
subtitle: jvm内存优化学习笔记
header-img: img/blog/2024-9-19/1.jpg
header-style: text
catalog: true
tags:
 - JVM内存调优
 - 内存泄漏
---
![](/img/blog/2024-9-19/1.jpg)
# 内存调优
均摘抄自[黑马](https://www.bilibili.com/video/BV1r94y1b7eS/?spm_id_from=333.1387.favlist.content.click&vd_source=e5b7a1b15de0bce6d08213c853db156e)
{:.info}
## 内存溢出和内存泄漏
 - **内存泄漏**：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏。（绝大多数情况都是由堆内存泄漏引起的）
 - **内存溢出**：少量的内存泄漏可以容忍，但是如果发生持续的内存泄漏，就像滚雪球雪球越滚越大，不管有多大的内存迟
早会被消耗完，最终导致的结果就是内存溢出。但是产生内存溢出并不是只有内存泄漏这一种原因。
### 常见场景
 - 内存泄漏导致溢出的常见场景是大型的Java后端应用中，在处理用户的请求之后，没有及时将用户的数据删除。随着用户请求数量越来越多，内存泄漏的对象占满了堆内存最终导致内存溢出。这种产生的内存溢出会直接导致用户请求无法处理，影响用户的正常使用。重启可以恢复应用使用，但是在运行一段时间之后依然会出现内存溢出。
 - 第二种常见场景是分布式任务调度系统如Elastic-job、Quartz等进行任务调度时，被调度的Java应用在调度任务结束中出现了内存泄漏，最终导致多次调度之后内存溢出。这种产生的内存溢出会导致应用执行下次的调度任务执行。同样重启可以恢复应用使用，但是在调度执行一
段时间之后依然会出现内存溢出。
##  解决内存溢出的方法
分为以下四个步骤，其中前两个步骤最重要：
![](/img/blog/2024-9-19/2.png)
### 发现问题
#### 常用监控工具
 - Top命令
 	- 优点：操作简单，无额外的软件安装
 	- 缺点：只能查看最基础的进程信息，无法查看到每个部分的内存占用（堆，方法区，堆外）
 - VisualVM
	- 优点：功能丰富，实时监控CPU、内存、线程等详细信息 支持Idea插件，开发过程中也可以使用
	- 缺点：对大量集群化部署的Java进程需要手动进行管理
 - Arthas
	- 优点：功能强大，不止于监控基础的信息，还能监控单个方法的执行耗时等细节内容。支持应用的集群管理
	- 缺点：部分高级功能使用门槛较高
 - Prometheus + Grafana
	- 优点：支持系统级别和应用级别的监控，比如linux操作系统、Redis、MySQL、Java进程。支持告警并允许自定义告警指标，通过邮件、短信等方式尽早通知相关人员进行处理
	- 缺点：环境搭建较为复杂，一般由运维人员完成
#### 1、equals()和hashCode()
##### 异常情况
- hashCode方法实现不正确，会导致相同id的学生对象计算出来的hash值不同，可能会被分到不同的槽中。
- equals方法实现不正确，会导致key在比对时，即便学生对象的id是相同的，也被认为是不同的key。
- 长时间运行之后HashMap中会保存大量相同id的学生数据。
![](/img/blog/2024-9-19/3.png)
##### 解决方案
- 在定义新实体时，始终重写equals()和hashCode()方法。
- 重写时一定要确定使用了唯一标识去区分不同的对象，比如用户的id等。
- hashmap使用时尽量使用编号id等数据作为key，不要将整个实体类对象作为key存放。
#### 2、内部类引用外部类
##### 异常情况
- 非静态的内部类默认会持有外部类，尽管代码上不再使用外部类，所以如果有地方引用了这个非静态内部类，会导致外部类也被引用，垃圾回收时无法回收这个外部类。
- 匿名内部类对象如果在非静态方法中被创建，会持有调用者对象，垃圾回收时无法回收调用者。
##### 解决方案
- 这个案例中，使用内部类的原因是可以直接获取到外部类中的成员变量值，简化开发。如果不想持有外部类对象，应该使用静态内部类。
- 使用静态方法，可以避免匿名内部类持有调用者对象。
#### 3、ThreadLocal的使用
##### 异常情况
- 如果仅仅使用手动创建的线程，就算没有调用ThreadLocal的remove方法清理数据，也不会产生内存泄漏。因为当线程被回收时，ThreadLocal也同样被回收。但是如果使用线程池就不一定了。
##### 解决方案
- 线程方法执行完，一定要调用ThreadLocal中的remove方法清理对象。
#### 4、String的intern方法
##### 异常情况
- JDK6中字符串常量池位于堆内存中的Perm Gen永久代中，如果不同字符串的intern方法被大量调用，字符串常量池会不停的变大超过永久代内存上限之后就会产生内存溢出问题。
##### 解决方案
- 注意代码中的逻辑，尽量不要将随机生成的字符串加入字符串常量池
- 增大永久代空间的大小，根据实际的测试/估算结果进行设置-XX:MaxPermSize=256M
#### 5、通过静态字段保存对象
##### 异常情况
- 如果大量的数据在静态变量中被长期引用，数据就不会被释放，如果这些数据不再使用，就成为了内存泄漏。
##### 解决方案
- 尽量减少将对象长时间的保存在静态变量中，如果不再使用，必须将对象删除（比如在集合中）或
者将静态变量设置为null。
- 使用单例模式时，尽量使用懒加载，而不是立即加载。
- Spring的Bean中不要长期存放大对象，如果是缓存用于提升性能，尽量设置过期时间定期失效。
#### 6、资源没有正常关闭
##### 异常情况
- 连接和流这些资源会占用内存，如果使用完之后没有关闭，这部分内存不一定会出现内存泄漏，但是会导致close方法不被执行。
##### 解决方案
- 为了防止出现这类的资源对象泄漏问题，必须在finally块中关闭不再使用的资源。
- 从 Java 7 开始，使用try-with-resources语法可以用于自动关闭资源。
#### 7、 并发请求问题
##### 异常情况
- 并发请求问题指的是用户通过发送请求向Java应用获取数据，正常情况下Java应用将数据返回之后，这部分数据就可以在内存中被释放掉。但是由于用户的并发请求量有可能很大，同时处理数据的时间很长，导致大量的数据存在于内存中，最终超过了内存的上限，导致内存溢出。
##### 解决方案
- 这类问题的处理思路和内存泄漏类似，首先要定位到对象产生的根源。


	

